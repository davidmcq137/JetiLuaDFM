{"version":3,"sources":["daiquiri/util.cljc"],"mappings":";AAIA,AAAA,AAAMA,AAAYC;AAAlB,AACE,AAAI,AAAAC,AAAUD,AACV,AAASA,AACT,AAAAE,AAASF;;AAEf,AAAA,AAAMG,AAAaH;AAAnB,AACE,AAAI,AAASA;AACXA;;AACA,AAAAI,AAA2B,AAAA,AAAQ,AAACQ,AAAKZ;AAAzCK,AAAA,AAAAC,AAAAF;AAAAG,AAAA,AAAAC,AAAAH;AAAAA,AAAA,AAAAI,AAAAJ;AAAAE,AAAOG;AAAPL,AAAoBM;AAApB,AACE,AAAI,AAAI,AAACE,AAAOF,AACR,AAAA,AAACG,AAASJ,AACV,AAAA,AAACI,AAASJ;AAChBV;;AACA,AAAA,AAAI,AAACe,AAAIC,AAAeL,AACpB,AAACM,AAAKP,AACNQ,AACAC;;;;AAEZ,AAAKC,AAAY,AAAA,AAACC;AAElB;;;;AAAA,AAAMC,AAGHtB;AAHH,AAIE,AAAI,AAACD,AAAWC;AACd,AAAAuB,AAAI,AAAA,AAAAC,AAACC,AAAKL,AAAYpB;AAAtB,AAAA,AAAAuB;AAAAA;;AACI,AAAMG,AAAG,AAACvB,AAAYH;AAAtB,AACE,AAAA,AAAA,AAAQoB,AAAAA,AAAYO,AAAM3B,AAAE0B;;AAC5BA;;;AACN1B;;;AAEJ,AAAA,AAAM4B,AAAkBC;AAAxB,AACE,AAAK,AAAA,AAAAC,AAAAC,AAAAC,AAACC,AAGDG;AAHA,AAAY,AAAAN,AAAAE,AAACE,AAAU,AAAAH,AAACT;AACb,AAAA,AAACa,AACDN;;AAGlB;;;AAAA,AAAMQ,AAEHR;AAFH,AAGE,AAAI,AAACS,AAAKT;AACR,AAAMA,AAAE,AACK,AAAA,AAAAU,AAAAC,AAAAC,AAACR,AAEDG;AAFA,AAAY,AAAAG,AAAAE,AAACP,AAAU,AAAAM,AAAClB;AADxBO,AAEW,AAAA,AAACM;AAFzB,AAIE,AAAAO,AAAQb;AAAR,AAAA,AACE,AAACS,AAAK,AAAA,AAAQT;AACd,AAAAa,AAAA,AAACC,AAAcN;;AAFjBK;;;AAGFb;;;AAEJ;;;AAAA,AAAMe,AAEHC;AAFH,AAGE,AAAI,AAAA,AAAC/B,AAAE,AAACF,AAAKiC,AACT,AAAA,AAAC/B,AAAE,AAACF,AAAKiC;;AAEf,AAAA,AAAMC,AAAWC;AAAjB,AACE,AAAK,AAACC,AAAQD,AACT,AAACH,AAAc,AAAA,AAAA,AAACK,AAAIF;;AAE3B;;;;AAAA,AAAMG,AAGHC;AAHH,AAIE,AAAK,AAACH,AAAQG,AACT,AAAAlD,AAAU,AAAA,AAAA,AAACgD,AAAIE;;AAEtB;;;AAAA,AAAMC,AAEHC;AAFH,AAGE,AAAA,AAAA,AAAA,AAAA,AAAA,AAACC,AAAY,AAACjB,AAAgBgB;;AAIhC;;;AAAA,AAAME,AAEHC;AAFH,AAIO,AAAA,AAACC,AAAQ,AAACC,AACA,AAACC,AAAO,AAAKR,AAEvB,AAAA,AAACjC;AAFiB,AAAQ,AAAI,AAASiC;AAAb,AAAiBA;;AAAG,AAAC7C,AAAI6C;;AAFnDK,AAGU,AAACI,AAAOC","names":["daiquiri.util/valid-key?","k","cljs.core/Keyword","cljs.core/Symbol","daiquiri.util/-camel-case","vec__51866","seq__51867","cljs.core/seq","first__51868","cljs.core/first","cljs.core/next","first-word","words","cljs.core/name","cljs.core/empty?","cljs.core._EQ_","cljs.core.map","clojure.string/capitalize","cljs.core.conj","clojure.string.join","cljs.core.keyword","daiquiri.util/attrs-cache","cljs.core/volatile!","daiquiri.util/camel-case","or__4160__auto__","cljs.core/deref","cljs.core.get","kk","cljs.core.assoc","daiquiri.util/camel-case-keys*","m","p1__51869#","p2__51870#","p3__51871#","cljs.core/reduce-kv","cljs.core.assoc_BANG_","cljs.core/transient","cljs.core/persistent!","daiquiri.util/camel-case-keys","cljs.core/map?","p1__51874#","p2__51875#","p3__51876#","G__51879","cljs.core.update","daiquiri.util/fragment-tag?","tag","daiquiri.util/fragment?","v","cljs.core/vector?","cljs.core.nth","daiquiri.util/element?","x","daiquiri.util/html-to-dom-attrs","attrs","clojure.set/rename-keys","daiquiri.util/join-classes","classes","cljs.core.into","cljs.core.comp","cljs.core.mapcat","cljs.core.remove","cljs.core/nil?"],"sourcesContent":["(ns daiquiri.util\n  (:require [clojure.set :refer [rename-keys]]\n            [clojure.string :as str]))\n\n(defn valid-key? [k]\n  (or (keyword? k)\n      (string? k)\n      (symbol? k)))\n\n(defn -camel-case [k]\n  (if (string? k)\n    k\n    (let [[first-word & words] (.split (name k) \"-\")]\n      (if (or (empty? words)\n              (= \"aria\" first-word)\n              (= \"data\" first-word))\n        k\n        (-> (map str/capitalize words)\n            (conj first-word)\n            str/join\n            keyword)))))\n\n(def attrs-cache (volatile! {}))\n\n(defn camel-case\n  \"Returns camel case version of the key, e.g. :http-equiv becomes :httpEquiv.\n  Does not convert string attributes.\"\n  [k]\n  (if (valid-key? k)\n    (or (get @attrs-cache k)\n        (let [kk (-camel-case k)]\n          (vswap! attrs-cache assoc k kk)\n          kk))\n    k))\n\n(defn camel-case-keys* [m]\n  (->> (reduce-kv #(assoc! %1 (camel-case %2) %3)\n                  (transient {})\n                  m)\n       persistent!))\n\n(defn camel-case-keys\n  \"Recursively transforms all map keys into camel case.\"\n  [m]\n  (if (map? m)\n    (let [m (->> m\n                 (reduce-kv #(assoc! %1 (camel-case %2) %3)\n                            (transient {}))\n                 persistent!)]\n      (cond-> m\n        (map? (:style m))\n        (update :style camel-case-keys)))\n    m))\n\n(defn fragment-tag?\n  \"Returns true if `tag` is the fragment tag \\\"*\\\" or \\\"<>\\\", otherwise false.\"\n  [tag]\n  (or (= (name tag) \"*\")\n      (= (name tag) \"<>\")))\n\n(defn fragment? [v]\n  (and (vector? v)\n       (fragment-tag? (nth v 0 nil))))\n\n(defn element?\n  \"Return true if `x` is an HTML element. True when `x` is a vector\n  and the first element is a keyword, e.g. `[:div]` or `[:div [:span \\\"x\\\"]`.\"\n  [x]\n  (and (vector? x)\n       (keyword? (nth x 0 nil))))\n\n(defn html-to-dom-attrs\n  \"Converts all HTML attributes to their DOM equivalents.\"\n  [attrs]\n  (rename-keys (camel-case-keys attrs)\n               {:class :className\n                :for :htmlFor}))\n\n(defn join-classes\n  \"Join the `classes` with a whitespace.\"\n  [classes]\n  (->> classes\n       (into [] (comp\n                 (mapcat (fn [x] (if (string? x) [x] (seq x))))\n                 (remove nil?)))\n       (str/join \" \")))\n"]}