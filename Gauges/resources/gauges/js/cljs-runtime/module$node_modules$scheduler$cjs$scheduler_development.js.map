{
"version":3,
"file":"module$node_modules$scheduler$cjs$scheduler_development.js",
"lineCount":22,
"mappings":"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",
"sources":["node_modules/scheduler/cjs/scheduler.development.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$scheduler$cjs$scheduler_development\"] = function(global,require,module,exports) {\n/** @license React v0.15.0\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar enableSchedulerDebugging = false;\nvar enableIsInputPending = false;\nvar requestIdleCallbackBeforeFirstFrame = false;\nvar requestTimerEventBeforeFirstFrame = false;\nvar enableMessageLoopImplementation = false;\n\n// The DOM Scheduler implementation is similar to requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\nvar requestHostCallback = void 0;\n\nvar requestHostTimeout = void 0;\nvar cancelHostTimeout = void 0;\nvar shouldYieldToHost = void 0;\nvar requestPaint = void 0;\nexports.unstable_now = void 0;\nexports.unstable_forceFrameRate = void 0;\n\nif (\n// If Scheduler runs in a non-DOM environment, it falls back to a naive\n// implementation using setTimeout.\ntypeof window === 'undefined' ||\n// Check if MessageChannel is supported, too.\ntypeof MessageChannel !== 'function') {\n  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,\n  // fallback to a naive implementation.\n  var _callback = null;\n  var _timeoutID = null;\n  var _flushCallback = function () {\n    if (_callback !== null) {\n      try {\n        var currentTime = exports.unstable_now();\n        var hasRemainingTime = true;\n        _callback(hasRemainingTime, currentTime);\n        _callback = null;\n      } catch (e) {\n        setTimeout(_flushCallback, 0);\n        throw e;\n      }\n    }\n  };\n  exports.unstable_now = function () {\n    return Date.now();\n  };\n  requestHostCallback = function (cb) {\n    if (_callback !== null) {\n      // Protect against re-entrancy.\n      setTimeout(requestHostCallback, 0, cb);\n    } else {\n      _callback = cb;\n      setTimeout(_flushCallback, 0);\n    }\n  };\n  requestHostTimeout = function (cb, ms) {\n    _timeoutID = setTimeout(cb, ms);\n  };\n  cancelHostTimeout = function () {\n    clearTimeout(_timeoutID);\n  };\n  shouldYieldToHost = function () {\n    return false;\n  };\n  requestPaint = exports.unstable_forceFrameRate = function () {};\n} else {\n  // Capture local references to native APIs, in case a polyfill overrides them.\n  var performance = window.performance;\n  var _Date = window.Date;\n  var _setTimeout = window.setTimeout;\n  var _clearTimeout = window.clearTimeout;\n  var requestAnimationFrame = window.requestAnimationFrame;\n  var cancelAnimationFrame = window.cancelAnimationFrame;\n  var requestIdleCallback = window.requestIdleCallback;\n\n  if (typeof console !== 'undefined') {\n    // TODO: Remove fb.me link\n    if (typeof requestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof cancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var requestIdleCallbackBeforeFirstFrame$1 = requestIdleCallbackBeforeFirstFrame && typeof requestIdleCallback === 'function' && typeof cancelIdleCallback === 'function';\n\n  exports.unstable_now = typeof performance === 'object' && typeof performance.now === 'function' ? function () {\n    return performance.now();\n  } : function () {\n    return _Date.now();\n  };\n\n  var isRAFLoopRunning = false;\n  var isMessageLoopRunning = false;\n  var scheduledHostCallback = null;\n  var rAFTimeoutID = -1;\n  var taskTimeoutID = -1;\n\n  var frameLength = enableMessageLoopImplementation ? // We won't attempt to align with the vsync. Instead we'll yield multiple\n  // times per frame, often enough to keep it responsive even at really\n  // high frame rates > 120.\n  5 : // Use a heuristic to measure the frame rate and yield at the end of the\n  // frame. We start out assuming that we run at 30fps but then the\n  // heuristic tracking will adjust this value to a faster fps if we get\n  // more frequent animation frames.\n  33.33;\n\n  var prevRAFTime = -1;\n  var prevRAFInterval = -1;\n  var frameDeadline = 0;\n\n  var fpsLocked = false;\n\n  // TODO: Make this configurable\n  // TODO: Adjust this based on priority?\n  var maxFrameLength = 300;\n  var needsPaint = false;\n\n  if (enableIsInputPending && navigator !== undefined && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined) {\n    var scheduling = navigator.scheduling;\n    shouldYieldToHost = function () {\n      var currentTime = exports.unstable_now();\n      if (currentTime >= frameDeadline) {\n        // There's no time left in the frame. We may want to yield control of\n        // the main thread, so the browser can perform high priority tasks. The\n        // main ones are painting and user input. If there's a pending paint or\n        // a pending input, then we should yield. But if there's neither, then\n        // we can yield less often while remaining responsive. We'll eventually\n        // yield regardless, since there could be a pending paint that wasn't\n        // accompanied by a call to `requestPaint`, or other main thread tasks\n        // like network events.\n        if (needsPaint || scheduling.isInputPending()) {\n          // There is either a pending paint or a pending input.\n          return true;\n        }\n        // There's no pending input. Only yield if we've reached the max\n        // frame length.\n        return currentTime >= frameDeadline + maxFrameLength;\n      } else {\n        // There's still time left in the frame.\n        return false;\n      }\n    };\n\n    requestPaint = function () {\n      needsPaint = true;\n    };\n  } else {\n    // `isInputPending` is not available. Since we have no way of knowing if\n    // there's pending input, always yield at the end of the frame.\n    shouldYieldToHost = function () {\n      return exports.unstable_now() >= frameDeadline;\n    };\n\n    // Since we yield every frame regardless, `requestPaint` has no effect.\n    requestPaint = function () {};\n  }\n\n  exports.unstable_forceFrameRate = function (fps) {\n    if (fps < 0 || fps > 125) {\n      console.error('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing framerates higher than 125 fps is not unsupported');\n      return;\n    }\n    if (fps > 0) {\n      frameLength = Math.floor(1000 / fps);\n      fpsLocked = true;\n    } else {\n      // reset the framerate\n      frameLength = 33.33;\n      fpsLocked = false;\n    }\n  };\n\n  var performWorkUntilDeadline = function () {\n    if (enableMessageLoopImplementation) {\n      if (scheduledHostCallback !== null) {\n        var currentTime = exports.unstable_now();\n        // Yield after `frameLength` ms, regardless of where we are in the vsync\n        // cycle. This means there's always time remaining at the beginning of\n        // the message event.\n        frameDeadline = currentTime + frameLength;\n        var hasTimeRemaining = true;\n        try {\n          var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n          if (!hasMoreWork) {\n            isMessageLoopRunning = false;\n            scheduledHostCallback = null;\n          } else {\n            // If there's more work, schedule the next message event at the end\n            // of the preceding one.\n            port.postMessage(null);\n          }\n        } catch (error) {\n          // If a scheduler task throws, exit the current browser task so the\n          // error can be observed.\n          port.postMessage(null);\n          throw error;\n        }\n      }\n      // Yielding to the browser will give it a chance to paint, so we can\n      // reset this.\n      needsPaint = false;\n    } else {\n      if (scheduledHostCallback !== null) {\n        var _currentTime = exports.unstable_now();\n        var _hasTimeRemaining = frameDeadline - _currentTime > 0;\n        try {\n          var _hasMoreWork = scheduledHostCallback(_hasTimeRemaining, _currentTime);\n          if (!_hasMoreWork) {\n            scheduledHostCallback = null;\n          }\n        } catch (error) {\n          // If a scheduler task throws, exit the current browser task so the\n          // error can be observed, and post a new task as soon as possible\n          // so we can continue where we left off.\n          port.postMessage(null);\n          throw error;\n        }\n      }\n      // Yielding to the browser will give it a chance to paint, so we can\n      // reset this.\n      needsPaint = false;\n    }\n  };\n\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n\n  var onAnimationFrame = function (rAFTime) {\n    if (scheduledHostCallback === null) {\n      // No scheduled work. Exit.\n      prevRAFTime = -1;\n      prevRAFInterval = -1;\n      isRAFLoopRunning = false;\n      return;\n    }\n\n    // Eagerly schedule the next animation callback at the beginning of the\n    // frame. If the scheduler queue is not empty at the end of the frame, it\n    // will continue flushing inside that callback. If the queue *is* empty,\n    // then it will exit immediately. Posting the callback at the start of the\n    // frame ensures it's fired within the earliest possible frame. If we\n    // waited until the end of the frame to post the callback, we risk the\n    // browser skipping a frame and not firing the callback until the frame\n    // after that.\n    isRAFLoopRunning = true;\n    requestAnimationFrame(function (nextRAFTime) {\n      _clearTimeout(rAFTimeoutID);\n      onAnimationFrame(nextRAFTime);\n    });\n\n    // requestAnimationFrame is throttled when the tab is backgrounded. We\n    // don't want to stop working entirely. So we'll fallback to a timeout loop.\n    // TODO: Need a better heuristic for backgrounded work.\n    var onTimeout = function () {\n      frameDeadline = exports.unstable_now() + frameLength / 2;\n      performWorkUntilDeadline();\n      rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\n    };\n    rAFTimeoutID = _setTimeout(onTimeout, frameLength * 3);\n\n    if (prevRAFTime !== -1 &&\n    // Make sure this rAF time is different from the previous one. This check\n    // could fail if two rAFs fire in the same frame.\n    rAFTime - prevRAFTime > 0.1) {\n      var rAFInterval = rAFTime - prevRAFTime;\n      if (!fpsLocked && prevRAFInterval !== -1) {\n        // We've observed two consecutive frame intervals. We'll use this to\n        // dynamically adjust the frame rate.\n        //\n        // If one frame goes long, then the next one can be short to catch up.\n        // If two frames are short in a row, then that's an indication that we\n        // actually have a higher frame rate than what we're currently\n        // optimizing. For example, if we're running on 120hz display or 90hz VR\n        // display. Take the max of the two in case one of them was an anomaly\n        // due to missed frame deadlines.\n        if (rAFInterval < frameLength && prevRAFInterval < frameLength) {\n          frameLength = rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval;\n          if (frameLength < 8.33) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If the calculated frame length gets lower than 8, it is probably\n            // a bug.\n            frameLength = 8.33;\n          }\n        }\n      }\n      prevRAFInterval = rAFInterval;\n    }\n    prevRAFTime = rAFTime;\n    frameDeadline = rAFTime + frameLength;\n\n    // We use the postMessage trick to defer idle work until after the repaint.\n    port.postMessage(null);\n  };\n\n  requestHostCallback = function (callback) {\n    scheduledHostCallback = callback;\n    if (enableMessageLoopImplementation) {\n      if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        port.postMessage(null);\n      }\n    } else {\n      if (!isRAFLoopRunning) {\n        // Start a rAF loop.\n        isRAFLoopRunning = true;\n        requestAnimationFrame(function (rAFTime) {\n          if (requestIdleCallbackBeforeFirstFrame$1) {\n            cancelIdleCallback(idleCallbackID);\n          }\n          if (requestTimerEventBeforeFirstFrame) {\n            _clearTimeout(idleTimeoutID);\n          }\n          onAnimationFrame(rAFTime);\n        });\n\n        // If we just missed the last vsync, the next rAF might not happen for\n        // another frame. To claim as much idle time as possible, post a\n        // callback with `requestIdleCallback`, which should fire if there's\n        // idle time left in the frame.\n        //\n        // This should only be an issue for the first rAF in the loop;\n        // subsequent rAFs are scheduled at the beginning of the\n        // preceding frame.\n        var idleCallbackID = void 0;\n        if (requestIdleCallbackBeforeFirstFrame$1) {\n          idleCallbackID = requestIdleCallback(function onIdleCallbackBeforeFirstFrame() {\n            if (requestTimerEventBeforeFirstFrame) {\n              _clearTimeout(idleTimeoutID);\n            }\n            frameDeadline = exports.unstable_now() + frameLength;\n            performWorkUntilDeadline();\n          });\n        }\n        // Alternate strategy to address the same problem. Scheduler a timer\n        // with no delay. If this fires before the rAF, that likely indicates\n        // that there's idle time before the next vsync. This isn't always the\n        // case, but we'll be aggressive and assume it is, as a trade off to\n        // prevent idle periods.\n        var idleTimeoutID = void 0;\n        if (requestTimerEventBeforeFirstFrame) {\n          idleTimeoutID = _setTimeout(function onTimerEventBeforeFirstFrame() {\n            if (requestIdleCallbackBeforeFirstFrame$1) {\n              cancelIdleCallback(idleCallbackID);\n            }\n            frameDeadline = exports.unstable_now() + frameLength;\n            performWorkUntilDeadline();\n          }, 0);\n        }\n      }\n    }\n  };\n\n  requestHostTimeout = function (callback, ms) {\n    taskTimeoutID = _setTimeout(function () {\n      callback(exports.unstable_now());\n    }, ms);\n  };\n\n  cancelHostTimeout = function () {\n    _clearTimeout(taskTimeoutID);\n    taskTimeoutID = -1;\n  };\n}\n\n/* eslint-disable no-var */\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nvar IDLE_PRIORITY = maxSigned31BitInt;\n\n// Tasks are stored as a circular, doubly linked list.\nvar firstTask = null;\nvar firstDelayedTask = null;\n\n// Pausing the scheduler is useful for debugging.\nvar isSchedulerPaused = false;\n\nvar currentTask = null;\nvar currentPriorityLevel = NormalPriority;\n\n// This is set while performing work, to prevent re-entrancy.\nvar isPerformingWork = false;\n\nvar isHostCallbackScheduled = false;\nvar isHostTimeoutScheduled = false;\n\nfunction scheduler_flushTaskAtPriority_Immediate(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_UserBlocking(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_Normal(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_Low(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_Idle(callback, didTimeout) {\n  return callback(didTimeout);\n}\n\nfunction flushTask(task, currentTime) {\n  // Remove the task from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = task.next;\n  if (next === task) {\n    // This is the only scheduled task. Clear the list.\n    firstTask = null;\n  } else {\n    // Remove the task from its position in the list.\n    if (task === firstTask) {\n      firstTask = next;\n    }\n    var previous = task.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n  task.next = task.previous = null;\n\n  // Now it's safe to execute the task.\n  var callback = task.callback;\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousTask = currentTask;\n  currentPriorityLevel = task.priorityLevel;\n  currentTask = task;\n  var continuationCallback;\n  try {\n    var didUserCallbackTimeout = task.expirationTime <= currentTime;\n    // Add an extra function to the callstack. Profiling tools can use this\n    // to infer the priority of work that appears higher in the stack.\n    switch (currentPriorityLevel) {\n      case ImmediatePriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Immediate(callback, didUserCallbackTimeout);\n        break;\n      case UserBlockingPriority:\n        continuationCallback = scheduler_flushTaskAtPriority_UserBlocking(callback, didUserCallbackTimeout);\n        break;\n      case NormalPriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Normal(callback, didUserCallbackTimeout);\n        break;\n      case LowPriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Low(callback, didUserCallbackTimeout);\n        break;\n      case IdlePriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Idle(callback, didUserCallbackTimeout);\n        break;\n    }\n  } catch (error) {\n    throw error;\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentTask = previousTask;\n  }\n\n  // A callback may return a continuation. The continuation should be scheduled\n  // with the same priority and expiration as the just-finished callback.\n  if (typeof continuationCallback === 'function') {\n    var expirationTime = task.expirationTime;\n    var continuationTask = task;\n    continuationTask.callback = continuationCallback;\n\n    // Insert the new callback into the list, sorted by its timeout. This is\n    // almost the same as the code in `scheduleCallback`, except the callback\n    // is inserted into the list *before* callbacks of equal timeout instead\n    // of after.\n    if (firstTask === null) {\n      // This is the first callback in the list.\n      firstTask = continuationTask.next = continuationTask.previous = continuationTask;\n    } else {\n      var nextAfterContinuation = null;\n      var t = firstTask;\n      do {\n        if (expirationTime <= t.expirationTime) {\n          // This task times out at or after the continuation. We will insert\n          // the continuation *before* this task.\n          nextAfterContinuation = t;\n          break;\n        }\n        t = t.next;\n      } while (t !== firstTask);\n      if (nextAfterContinuation === null) {\n        // No equal or lower priority task was found, which means the new task\n        // is the lowest priority task in the list.\n        nextAfterContinuation = firstTask;\n      } else if (nextAfterContinuation === firstTask) {\n        // The new task is the highest priority task in the list.\n        firstTask = continuationTask;\n      }\n\n      var _previous = nextAfterContinuation.previous;\n      _previous.next = nextAfterContinuation.previous = continuationTask;\n      continuationTask.next = nextAfterContinuation;\n      continuationTask.previous = _previous;\n    }\n  }\n}\n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  if (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime) {\n    do {\n      var task = firstDelayedTask;\n      var next = task.next;\n      if (task === next) {\n        firstDelayedTask = null;\n      } else {\n        firstDelayedTask = next;\n        var previous = task.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n      task.next = task.previous = null;\n      insertScheduledTask(task, task.expirationTime);\n    } while (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime);\n  }\n}\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (firstTask !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else if (firstDelayedTask !== null) {\n      requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n    }\n  }\n}\n\nfunction flushWork(hasTimeRemaining, initialTime) {\n  // Exit right away if we're currently paused\n  if (enableSchedulerDebugging && isSchedulerPaused) {\n    return;\n  }\n\n  // We'll need a host callback the next time work is scheduled.\n  isHostCallbackScheduled = false;\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  var currentTime = initialTime;\n  advanceTimers(currentTime);\n\n  isPerformingWork = true;\n  try {\n    if (!hasTimeRemaining) {\n      // Flush all the expired callbacks without yielding.\n      // TODO: Split flushWork into two separate functions instead of using\n      // a boolean argument?\n      while (firstTask !== null && firstTask.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused)) {\n        flushTask(firstTask, currentTime);\n        currentTime = exports.unstable_now();\n        advanceTimers(currentTime);\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstTask !== null) {\n        do {\n          flushTask(firstTask, currentTime);\n          currentTime = exports.unstable_now();\n          advanceTimers(currentTime);\n        } while (firstTask !== null && !shouldYieldToHost() && !(enableSchedulerDebugging && isSchedulerPaused));\n      }\n    }\n    // Return whether there's additional work\n    if (firstTask !== null) {\n      return true;\n    } else {\n      if (firstDelayedTask !== null) {\n        requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n      }\n      return false;\n    }\n  } finally {\n    isPerformingWork = false;\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel;\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n}\n\nfunction timeoutForPriorityLevel(priorityLevel) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      return IMMEDIATE_PRIORITY_TIMEOUT;\n    case UserBlockingPriority:\n      return USER_BLOCKING_PRIORITY;\n    case IdlePriority:\n      return IDLE_PRIORITY;\n    case LowPriority:\n      return LOW_PRIORITY_TIMEOUT;\n    case NormalPriority:\n    default:\n      return NORMAL_PRIORITY_TIMEOUT;\n  }\n}\n\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n  var currentTime = exports.unstable_now();\n\n  var startTime;\n  var timeout;\n  if (typeof options === 'object' && options !== null) {\n    var delay = options.delay;\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n    timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel);\n  } else {\n    timeout = timeoutForPriorityLevel(priorityLevel);\n    startTime = currentTime;\n  }\n\n  var expirationTime = startTime + timeout;\n\n  var newTask = {\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: startTime,\n    expirationTime: expirationTime,\n    next: null,\n    previous: null\n  };\n\n  if (startTime > currentTime) {\n    // This is a delayed task.\n    insertDelayedTask(newTask, startTime);\n    if (firstTask === null && firstDelayedTask === newTask) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      }\n      // Schedule a timeout.\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    insertScheduledTask(newTask, expirationTime);\n    // Schedule a host callback, if needed. If we're already performing work,\n    // wait until the next time we yield.\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n\n  return newTask;\n}\n\nfunction insertScheduledTask(newTask, expirationTime) {\n  // Insert the new task into the list, ordered first by its timeout, then by\n  // insertion. So the new task is inserted after any other task the\n  // same timeout\n  if (firstTask === null) {\n    // This is the first task in the list.\n    firstTask = newTask.next = newTask.previous = newTask;\n  } else {\n    var next = null;\n    var task = firstTask;\n    do {\n      if (expirationTime < task.expirationTime) {\n        // The new task times out before this one.\n        next = task;\n        break;\n      }\n      task = task.next;\n    } while (task !== firstTask);\n\n    if (next === null) {\n      // No task with a later timeout was found, which means the new task has\n      // the latest timeout in the list.\n      next = firstTask;\n    } else if (next === firstTask) {\n      // The new task has the earliest expiration in the entire list.\n      firstTask = newTask;\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newTask;\n    newTask.next = next;\n    newTask.previous = previous;\n  }\n}\n\nfunction insertDelayedTask(newTask, startTime) {\n  // Insert the new task into the list, ordered by its start time.\n  if (firstDelayedTask === null) {\n    // This is the first task in the list.\n    firstDelayedTask = newTask.next = newTask.previous = newTask;\n  } else {\n    var next = null;\n    var task = firstDelayedTask;\n    do {\n      if (startTime < task.startTime) {\n        // The new task times out before this one.\n        next = task;\n        break;\n      }\n      task = task.next;\n    } while (task !== firstDelayedTask);\n\n    if (next === null) {\n      // No task with a later timeout was found, which means the new task has\n      // the latest timeout in the list.\n      next = firstDelayedTask;\n    } else if (next === firstDelayedTask) {\n      // The new task has the earliest expiration in the entire list.\n      firstDelayedTask = newTask;\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newTask;\n    newTask.next = next;\n    newTask.previous = previous;\n  }\n}\n\nfunction unstable_pauseExecution() {\n  isSchedulerPaused = true;\n}\n\nfunction unstable_continueExecution() {\n  isSchedulerPaused = false;\n  if (!isHostCallbackScheduled && !isPerformingWork) {\n    isHostCallbackScheduled = true;\n    requestHostCallback(flushWork);\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return firstTask;\n}\n\nfunction unstable_cancelCallback(task) {\n  var next = task.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (task === next) {\n    if (task === firstTask) {\n      firstTask = null;\n    } else if (task === firstDelayedTask) {\n      firstDelayedTask = null;\n    }\n  } else {\n    if (task === firstTask) {\n      firstTask = next;\n    } else if (task === firstDelayedTask) {\n      firstDelayedTask = next;\n    }\n    var previous = task.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  task.next = task.previous = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nfunction unstable_shouldYield() {\n  var currentTime = exports.unstable_now();\n  advanceTimers(currentTime);\n  return currentTask !== null && firstTask !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\n}\n\nvar unstable_requestPaint = requestPaint;\n\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_next = unstable_next;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_shouldYield = unstable_shouldYield;\nexports.unstable_requestPaint = unstable_requestPaint;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n  })();\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","flushTask","task","currentTime","next","firstTask","previous","callback","previousPriorityLevel","currentPriorityLevel","previousTask","currentTask","priorityLevel","didUserCallbackTimeout","expirationTime","ImmediatePriority","continuationCallback","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","error","nextAfterContinuation","t","_previous","advanceTimers","firstDelayedTask","startTime","insertScheduledTask","handleTimeout","isHostTimeoutScheduled","isHostCallbackScheduled","requestHostCallback","flushWork","requestHostTimeout","hasTimeRemaining","initialTime","cancelHostTimeout","isPerformingWork","unstable_now","shouldYieldToHost","timeoutForPriorityLevel","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","maxSigned31BitInt","LOW_PRIORITY_TIMEOUT","NORMAL_PRIORITY_TIMEOUT","newTask","Object","defineProperty","value","requestPaint","unstable_forceFrameRate","window","MessageChannel","_callback","_timeoutID","_flushCallback","hasRemainingTime","e","setTimeout","exports.unstable_now","Date","now","cb","ms","clearTimeout","exports.unstable_forceFrameRate","performance","_Date","_setTimeout","_clearTimeout","requestAnimationFrame","cancelAnimationFrame","console","isRAFLoopRunning","scheduledHostCallback","rAFTimeoutID","taskTimeoutID","frameLength","prevRAFTime","prevRAFInterval","frameDeadline","fpsLocked","fps","Math","floor","performWorkUntilDeadline","_currentTime","_hasTimeRemaining","_hasMoreWork","port","postMessage","channel","port2","port1","onmessage","onAnimationFrame","rAFTime","nextRAFTime","onTimeout","rAFInterval","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","unstable_LowPriority","unstable_runWithPriority","eventHandler","unstable_next","unstable_scheduleCallback","options","delay","timeout","unstable_cancelCallback","unstable_wrapCallback","parentPriorityLevel","apply","arguments","unstable_getCurrentPriorityLevel","unstable_shouldYield","unstable_requestPaint","unstable_continueExecution","unstable_pauseExecution","unstable_getFirstCallbackNode"]
}
