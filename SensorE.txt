   SensorE.lua

   Summary
   
   When writing lua scripts for the Jeti transmitters, telemetry
   sensors can be one of the most important sources of data for the
   script. If you develop lua scripts on the Jeti DC/DS-24 emulator as
   I do, it would be quite convenient to have a way to provide what
   look like actual sensor readings on the emulator. In the past, I
   had used a DEBUG variable, or I had queried the system routines to
   know I was running on the emulator, then would add lua code to my
   source files to insert computed values instead of calling the
   system telemetry routines. Typically I would use the analog sliders
   P5-P8 as data sources for this purpose. But the issue is that the
   code path for the debugging is then different than it is at
   runtime.

   For a long time I have wanted to have the ability to call the
   standard system routines (e.g. system.getSensorByID) and have them
   return values that are similar to what the lua app would encounter
   in actual flight. The tools described here are the first
   implementation of that vision. This tool, SensorE.lua can read a
   json file that describes a set of sensors, and the values they
   should return.

   The format of the json file (sensorEmulator.jsn) has the same structure
   as the json representation of the table that system.getSensors()
   returns in normal use, so it should be familiar.
   
   On its initialization this app replaces the system routines such as
   system.getSensors and system.getSensorByID with its own
   implementations, and returns values in a way that is specified in
   the json file. The file allows the creation of a range from min to
   max for each analog slider and also allows you to specify a lua
   expression that transforms this simple linear range to whatever you
   like.

   The tool can also simulate GPS sensors by giving a lat,long origin
   and specifying the x and y values for a parametric equation that
   can do things such as generating an ellipse or lissajous figure
   flight path and return the appropriate GPS values in sensor.valGPS.
   This information is specified in a second json file
   sensorEmulatorGPS.jsn.

   There is also a separate tool SensorL.lua that reads a Jeti TX
   log file and plays back selected sensors (these sensors are defined
   in a json file) so that calls to the system telemetry routines work
   as if the lua script is "flying" that flight.

   Details
   
   The SensorE.lua app is intended to be used with the Jeti DC/DS-24
   emulator. It reads the file SensorE.jsn to see where it should find
   the actual config file (sensorEmulator.jsn) that defines a set of
   "pseudosensors" that can be created from the proportional controls
   (e.g. sliders) in the emulator or from arbitrary lua
   expressions. As a simple example, you can define a simple linear
   range of telemetry signal values that behave as standard telemetry
   sensors as the sliders move. A sample JSON file is included below.
   
   For more complex sensor behavior, you can specify a string of lua
   code that is interpreted as a lua expression (basically anything
   that could be after "return" in a function call). You specify this
   in the jsn file with key "luaExp" whose value is the expression to
   be evaluated by the lua interpreter (see example below). This
   expression is evaluated each time the sensor is "read"
   
   The environment in which that string is evaluated by the lua
   interpreter is set up so that variable name s is the pseudo sensor
   value (which will be returned as sensor.value), t is the system time in seconds
   (t = system.getTimeCounter() / 1000), dt is time elapsed since this
   sensor was last read, and most of the lua math library is available
   - without the "math." prefix (see the code and look for table
   env). Also available are a triangle wave function tri() with a
   period of 1s and a square wave function sq() with a period of
   1s. The triangle and square wave functions have an amplitude of
   +/-1. For convenience we also have the trig functions with a period
   of 1: sin1(), cos1() and tan1() .. this way you can use the same
   time argument as sq and tri .. e.g. sq(t/10) and sin1(t/10) will
   both have a period of 10 seconds. The regular trig functions have a
   period of 2*pi as expected.

   a Sequencing function is availble, seq(t, table) where t is the
   time argument and the second parameter is a table. seq() divides is
   period up into n equal time segments and steps through the entries
   in the table in order. The amplitude of the seq function is equal
   to the table entry. For example seq(t/20, {1,2,3,4}) creates a 20
   second period repeating "staircase" function. from t=0 to t=5 it
   has a value of 1, from t=5 to t=10 a value of 2, from t=10 to t=15
   a value of 3 and from t=15 to t=20 a value of 4, at which point it
   wraps around back to 1.

   In addition, you can specify a json array of auxiliary
   controls. These are other proportional controls in addition to the
   primary one specified by the "control" key in the json, and the
   value of these controls will also be available in the lua
   environment and can be used in your lua expression. They go into a
   json array with key "auxcontrol".  See the example jsn file
   below. They are available as "raw" values (-1 to 1) by their Jeti
   name e.g. P6, and for convenience they are also available with an
   "S" (e.g. S6) going from (0 to 1). The primary control, for example
   P5, is available as noted above scaled from "controlmin" to
   "controlmax" as variable s, and is also available as the "raw"
   value via variables P5 and S5 going from (-1 to 1) and (0 to 1)
   respectively.
   
   For example "luaExp":"s*sin(2*pi*t/10)" gives a 10 second
   period sine wave whose amplitude is set by the slider.

   "luaExp":"s*sin(2*pi*t/10) + S6*rand() gives the same sine wave
   with a variable anount of noise added from the math.random
   function, with the noise amplitude going from 0 to 1 controlled by
   slider S6.

   You may declare global variables to be used in any of the luaExp
   strings. These will also be persistent. To initialize these global
   variables, you add an initString key to the first element of the
   jsn table in sensorEmulator.jsn. The first line in
   sensorEmulator.jsn will be the line with a new sensor ID, param of
   0 and label equal to the sensor name. to that table, add element
   "initString":"a=1;b=2;c=3" .. like this:

    {"id":16819272, "param": 0,"sensorName": "", "label": "IBP",
    "initString":"a=1;b=2;c=3"},

   The lua expression in initString will be executed one and only one
   time when the sensor table is first read in the system.getSensors()
   call. Note that initString will be evaluated as a "chunk" of lua
   code, not treated as the return paramater as it would be with
   luaExp.

   In addition to specifying a luaExp for each individual sensor (each
   ID/param pair) you may also specify a luaFunc sting. The luaFunc
   string will be evaluated as a lua chunk, not as a return value
   which allows you total flexibility to actually "write code" in the
   string. You may include a "return x" statement in luaFunc if you
   wish, and skip luaExp. Since there is no numeric return from
   luaFunc, you must either explicitly include a return value or you
   can use a luaExp string in addition to luaFunc if you wish. luaFunc
   is evaluated before luaExp as you would expect.

   Example - for sensors emulating a battery monitor, for the current
   sensor you might have this block of json in sensorEmulator.jsn:
   
    {"id":16819272,
     "param": 10,
     "decimals": 0,
     "type": 1,
     "sensorName": "IBP",
     "control": "P7",
     "controlmin": 0,
     "controlmax": -4000,
     "luaFunc":"Current=s; if CapLeft > 0 then return s+200*rand() else return 0 end",
     "label": "Current",
     "unit": "mA"
    },

   We are presuming that the variable Current was declared in the
   initString at the top of the jsn file, for example:

    {"id":16819272, "param": 0,"sensorName": "", "label": "IBP",
     "initString":"CapTotal=5000; CapLeft=5000; Current=0"},
   
   Note the use of rand() to generate some noise for realism, and how
   it is setting a global variable (Current) so that other sensors
   json blocks can refer to it by the same name. Of course the
   variable s will be the value derived from control P7 as it ranges
   from -1 to 1 the value of s will range from 0 to -4000ma (-4A).

   A further example from a battery monitor emulator file:
   
    {"id":16819272,
     "param": 6,
     "decimals": 0,
     "type": 1,
     "auxcontrol": ["P6"],
     "sensorName": "IBP",
     "control": "P7",
     "controlmin": 0,
     "controlmax": 5000,
     "luaFunc":"CapLeft = max(0, CapLeft + dt * Current/3600); return CapLeft",
     "label": "Cap. left",
     "unit": "mAh"
    },

   This assumes the pack capacity is specified in mAh. CapLeft is the
   number of mAh left in the pack, CapTotal is the mAh capacity of the
   pack, and Current is the discharge current in ma, with the
   convention that a negative value is a d ischarge. These variables
   would have been delcared at the top of the file in the
   initString. The variable dt is supplied and indicates the
   time in seconds since this sensor (the ID/param pair) was read. The
   pre-defined variable dt is in seconds so we divide by 3600 to get
   hours.

   Also available is a print function prt() that can be used in
   expressions for info or debugging. It is a variadic function and
   can take any list of args that would go to the normal lua print
   statement. The prt() function always returns 0 so you can add it
   (perhaps several times) to the end of your expression:
   "luaExp":"s*sin(2*pi*t/10) + prt('amp:', s) + prt('per:',10)".
   Note the use of single quotes around the strings in the expression.

   Support for generating GPS sensor info has also been added, along
   with a companion jsn file sensorEmulatorGPS.jsn that contains the
   local origin specified as lat, lon, the radius of the earth in the
   desired units (e.g. ft, m), and strings for creating a parametric
   equation of x and y (e.g. a Lissajous figure) for testing GPS
   applications. This file is also intended to be in the app's own
   directory just like sensorEmulator.jsn. Note that the figure drawn
   as a parametric equation of x and y will then cause the emulator to
   create the lat,long values that create the same figure, at the
   given lat/long origin point. Also note that the earth radius sets
   the units.  Specify the earth radius in the correct local units
   (e.g. ft, meters).

   At present, several less common table entries (see source code) are
   not implemented e.g. date and time. Easy to add if desired, format
   of date and time values can be observed in SensorL.lua.
   
   Future enhancements could be the addition of switches to emulate
   the behavior of table entry <sensor.valid>. Currently we always
   return sensor.valid = true.  Perhaps to avoid excessive CPU load we
   might only return a new value (running the lua interpreter) every
   200 msec or so to simulate actual telemetry sensor behavior. This
   could be an option in the jsn file.
   
   There is a companion lua program SensorL.lua that is similar,
   except that it reads a Jeti TX log file and replays the log file
   and supplies sensor data for selected sensors as they occured
   during the flight. This allows you to debug a lua program with
   actual flight data from a prior flight with your lua code exactly
   as it would be when deployed on the TX.

   The app file SensorE.lua is intended to be in the /Apps
   directory along with the lua source files. The sensorEmulator.jsn
   file and its GPS counterpart (if used) is expected to be
   lua-program-specific so it resides in the lua program's own
   directory, e.g. Apps/DFM-Smoke/sensorEmulator.jsn for use with the
   lua program /Apps/DFM-Smoke.lua

   The app makes one telemetry window where it displays the current
   sensors and values being emulated.

   Usage: 

   Put the sourcecode file SensorE.lua in the /Apps directory.

   Put a copy of the sensorEmulator.jsn file into the directory for
   the lua function that is going to use it, and edit it as required
   for that lua app. Ditto for sensorEmulatorGPS.jsn. Edit SensorE.jsn
   to point to those directories.

   By putting the sensorEmulator.jsn file into the app's own
   directory each app can define its own sensor names, ranges, etc

   The app file SensorE.lua is intended to be in the /Apps
   directory along with the lua source files. The sensorEmulator.jsn
   file and its GPS counterpart (if used) is expected to be
   lua-program-specific so it resides in the lua program's own
   directory, e.g. Apps/DFM-Smoke/sensorEmulator.jsn for use with the
   lua program /Apps/DFM-Smoke.lua

   The app makes one telemetry window where it displays the current
   sensors and values being emulated.

   Usage: 

   Put the sourcecode file SensorE.lua in the /Apps directory.

   No changes are required to lua apps that run with SensorE.
   
   When SensorE.lua is running, system function calls for
   system.getSensors(), system.getSensorById() and
   system.getSensorValueById() are rerouted to instead be handled by
   the emulator app functions with the pseudosensor
   functionality. Your sourcecode does not change and still has the
   calls to the system names in any case which is very convenient for
   debugging.

   The luaExp capability is inspired by Jeti's (very cool!)
   V-sensor.lua app. Thanks to Martin F at Jeti for suggesting to move
   this from a "require" module to a standalone app.

   Dave McQueeney Dec 2019
   SensorE.lua and SensorL.lua released under the MIT license.

Example SensorE.jsn file:

{
"configDir":"Apps/DFM-Graph"
}

Example sensorEmulator.jsn file:

[

{"id":1,"param":0,"sensorName":"", "label":"PS1(P5)"},
{"id":1,"param":1,
"decimals":0,
"type":1,
"sensorName":"PS1(P5)",
"label":"EGT",
"unit":"°C",
"control":"P5",
"auxcontrol":["P6","P7"],
"controlmin":0,
"controlmax":800,
"luaExp":"s / 2 * sin(2*pi*t / ( 30*(S7+1) ) ) + s / 2"
},

{"id":2,"param":0,"sensorName":"", "label":"PS2(P6)"},
{"id":2,
"param":1,
"decimals":0,
"type":1,
"sensorName":"PS2(P6)",
"label":"Airspeed",
"unit":"m/s",
"control":"P6",
"auxcontrol":["P7"],
"controlmin":0,
"controlmax":200,
"luaExp":"s / 2 * sq(t / (30*(S7+1) ) ) + s / 2 + s / 5 * rand() + s / 5"
},

{"id":3,"param":0,"sensorName":"", "label":"PS3(Lat)"},
{"id":3,
"param":2,
"decimals":0,
"type":9,
"auxcontrol":["P6","P7"],
"sensorName":"PS3(Lat)",
"label":"Latitude",
"unit":""
}, 

{"id":4,"param":0,"sensorName":"", "label":"PS3(Lon)"},
{"id":4,
"param":3,
"decimals":0,
"type":9,
"auxcontrol":["P5","P6"],
"sensorName":"PS3(Lon)",
"label":"Longitude",
"unit":""
}

]

Example sensorEmulatorGPS.jsn file:

{
    "lat0":41.00,
    "lon0":-73.00,
    "rE":21220539.7,
    "xString":"300*sin(2*pi*t/5)",
    "yString":"200*cos(2*pi*t/7)"
}
